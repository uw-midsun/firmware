/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.11.2 Sat Mar  2 16:18:21 2019.
 */

#ifndef SYSTEM_CAN_H
#define SYSTEM_CAN_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifndef EINVAL
#define EINVAL 22
#endif

#define SYSTEM_CAN_BPS_HEARTBEAT_FRAME_ID (0x01u)
#define SYSTEM_CAN_BPS_HEARTBEAT_ACK_FROM_CHAOS_FRAME_ID (0x13u)
#define SYSTEM_CAN_BPS_HEARTBEAT_ACK_FROM_LIGHTS_FRONT_FRAME_ID (0x15u)
#define SYSTEM_CAN_BPS_HEARTBEAT_ACK_FROM_PLUTUS_SLAVE_FRAME_ID (0x12u)
#define SYSTEM_CAN_BPS_HEARTBEAT_ACK_FROM_DRIVER_CONTROLS_FRAME_ID (0x18u)
#define SYSTEM_CAN_POWER_DISTRIBUTION_FAULT_FRAME_ID (0x23u)
#define SYSTEM_CAN_POWER_DISTRIBUTION_FAULT_ACK_FROM_DRIVER_CONTROLS_FRAME_ID (0x38u)
#define SYSTEM_CAN_BATTERY_RELAY_MAIN_FRAME_ID (0x43u)
#define SYSTEM_CAN_BATTERY_RELAY_MAIN_ACK_FROM_PLUTUS_FRAME_ID (0x51u)
#define SYSTEM_CAN_BATTERY_RELAY_SLAVE_FRAME_ID (0x63u)
#define SYSTEM_CAN_BATTERY_RELAY_SLAVE_ACK_FROM_PLUTUS_SLAVE_FRAME_ID (0x72u)
#define SYSTEM_CAN_MOTOR_RELAY_FRAME_ID (0x83u)
#define SYSTEM_CAN_MOTOR_RELAY_ACK_FROM_MOTOR_CONTROLLER_FRAME_ID (0x97u)
#define SYSTEM_CAN_SOLAR_RELAY_REAR_FRAME_ID (0xa3u)
#define SYSTEM_CAN_SOLAR_RELAY_REAR_ACK_FROM_SOLAR_MASTER_REAR_FRAME_ID (0xbbu)
#define SYSTEM_CAN_SOLAR_RELAY_FRONT_FRAME_ID (0xc3u)
#define SYSTEM_CAN_SOLAR_RELAY_FRONT_ACK_FROM_SOLAR_MASTER_FRONT_FRAME_ID (0xdau)
#define SYSTEM_CAN_POWER_STATE_FRAME_ID (0xe8u)
#define SYSTEM_CAN_POWER_STATE_ACK_FROM_CHAOS_FRAME_ID (0xf3u)
#define SYSTEM_CAN_POWERTRAIN_HEARTBEAT_FRAME_ID (0x103u)
#define SYSTEM_CAN_POWERTRAIN_HEARTBEAT_ACK_FROM_PLUTUS_FRAME_ID (0x111u)
#define SYSTEM_CAN_POWERTRAIN_HEARTBEAT_ACK_FROM_MOTOR_CONTROLLER_FRAME_ID (0x117u)
#define SYSTEM_CAN_POWERTRAIN_HEARTBEAT_ACK_FROM_DRIVER_CONTROLS_FRAME_ID (0x118u)
#define SYSTEM_CAN_MOTOR_CONTROLLER_RESET_FRAME_ID (0x1e8u)
#define SYSTEM_CAN_OVUV_DCDC_AUX_FRAME_ID (0x203u)
#define SYSTEM_CAN_MC_ERROR_LIMITS_FRAME_ID (0x227u)
#define SYSTEM_CAN_DRIVE_OUTPUT_FRAME_ID (0x248u)
#define SYSTEM_CAN_CRUISE_TARGET_FRAME_ID (0x268u)
#define SYSTEM_CAN_FAN_CONTROL_FRAME_ID (0x283u)
#define SYSTEM_CAN_SET_DISCHARGE_BITSET_FRAME_ID (0x2a4u)
#define SYSTEM_CAN_DISCHARGE_STATE_FRAME_ID (0x2c1u)
#define SYSTEM_CAN_LIGHTS_SYNC_FRAME_ID (0x2e6u)
#define SYSTEM_CAN_LIGHTS_STATE_FRAME_ID (0x308u)
#define SYSTEM_CAN_HORN_FRAME_ID (0x328u)
#define SYSTEM_CAN_CHARGER_CONN_STATE_FRAME_ID (0x34du)
#define SYSTEM_CAN_CHARGER_SET_RELAY_STATE_FRAME_ID (0x363u)
#define SYSTEM_CAN_STEERING_ANGLE_FRAME_ID (0x388u)
#define SYSTEM_CAN_BATTERY_SOC_FRAME_ID (0x3e1u)
#define SYSTEM_CAN_BATTERY_VT_FRAME_ID (0x401u)
#define SYSTEM_CAN_BATTERY_AGGREGATE_VC_FRAME_ID (0x421u)
#define SYSTEM_CAN_MOTOR_CONTROLLER_VC_FRAME_ID (0x467u)
#define SYSTEM_CAN_MOTOR_VELOCITY_FRAME_ID (0x487u)
#define SYSTEM_CAN_MOTOR_DEBUG_FRAME_ID (0x4a7u)
#define SYSTEM_CAN_MOTOR_TEMPS_FRAME_ID (0x4c7u)
#define SYSTEM_CAN_MOTOR_AMP_HR_FRAME_ID (0x4e7u)
#define SYSTEM_CAN_ODOMETER_FRAME_ID (0x507u)
#define SYSTEM_CAN_AUX_DCDC_VC_FRAME_ID (0x563u)
#define SYSTEM_CAN_DCDC_TEMPS_FRAME_ID (0x583u)
#define SYSTEM_CAN_SOLAR_DATA_FRONT_FRAME_ID (0x5aau)
#define SYSTEM_CAN_SOLAR_DATA_REAR_FRAME_ID (0x5cbu)
#define SYSTEM_CAN_CHARGER_INFO_FRAME_ID (0x5edu)
#define SYSTEM_CAN_LINEAR_ACCELERATION_FRAME_ID (0x66cu)
#define SYSTEM_CAN_ANGULAR_ROTATION_FRAME_ID (0x68cu)

/**
 * Signals in message BPS_HEARTBEAT.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_bps_heartbeat_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t status;
};

/**
 * Signals in message BPS_HEARTBEAT_ACK_FROM_CHAOS.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_bps_heartbeat_ack_from_chaos_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t bps_heartbeat_from_chaos_ack_status;
};

/**
 * Signals in message BPS_HEARTBEAT_ACK_FROM_LIGHTS_FRONT.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_bps_heartbeat_ack_from_lights_front_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t bps_heartbeat_from_lights_front_ack_status;
};

/**
 * Signals in message BPS_HEARTBEAT_ACK_FROM_PLUTUS_SLAVE.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_bps_heartbeat_ack_from_plutus_slave_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t bps_heartbeat_from_plutus_slave_ack_status;
};

/**
 * Signals in message BPS_HEARTBEAT_ACK_FROM_DRIVER_CONTROLS.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_bps_heartbeat_ack_from_driver_controls_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t bps_heartbeat_from_driver_controls_ack_status;
};

/**
 * Signals in message POWER_DISTRIBUTION_FAULT.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_power_distribution_fault_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t reason;
};

/**
 * Signals in message POWER_DISTRIBUTION_FAULT_ACK_FROM_DRIVER_CONTROLS.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_power_distribution_fault_ack_from_driver_controls_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t power_distribution_fault_from_driver_controls_ack_status;
};

/**
 * Signals in message BATTERY_RELAY_MAIN.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_battery_relay_main_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t relay_state;
};

/**
 * Signals in message BATTERY_RELAY_MAIN_ACK_FROM_PLUTUS.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_battery_relay_main_ack_from_plutus_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t battery_relay_main_from_plutus_ack_status;
};

/**
 * Signals in message BATTERY_RELAY_SLAVE.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_battery_relay_slave_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t relay_state;
};

/**
 * Signals in message BATTERY_RELAY_SLAVE_ACK_FROM_PLUTUS_SLAVE.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_battery_relay_slave_ack_from_plutus_slave_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t battery_relay_slave_from_plutus_slave_ack_status;
};

/**
 * Signals in message MOTOR_RELAY.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_motor_relay_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t relay_state;
};

/**
 * Signals in message MOTOR_RELAY_ACK_FROM_MOTOR_CONTROLLER.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_motor_relay_ack_from_motor_controller_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t motor_relay_from_motor_controller_ack_status;
};

/**
 * Signals in message SOLAR_RELAY_REAR.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_solar_relay_rear_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t relay_state;
};

/**
 * Signals in message SOLAR_RELAY_REAR_ACK_FROM_SOLAR_MASTER_REAR.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_solar_relay_rear_ack_from_solar_master_rear_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t solar_relay_rear_from_solar_master_rear_ack_status;
};

/**
 * Signals in message SOLAR_RELAY_FRONT.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_solar_relay_front_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t relay_state;
};

/**
 * Signals in message SOLAR_RELAY_FRONT_ACK_FROM_SOLAR_MASTER_FRONT.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_solar_relay_front_ack_from_solar_master_front_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t solar_relay_front_from_solar_master_front_ack_status;
};

/**
 * Signals in message POWER_STATE.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_power_state_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t power_state;
};

/**
 * Signals in message POWER_STATE_ACK_FROM_CHAOS.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_power_state_ack_from_chaos_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t power_state_from_chaos_ack_status;
};

/**
 * Signals in message POWERTRAIN_HEARTBEAT.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_powertrain_heartbeat_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message POWERTRAIN_HEARTBEAT_ACK_FROM_PLUTUS.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_powertrain_heartbeat_ack_from_plutus_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t powertrain_heartbeat_from_plutus_ack_status;
};

/**
 * Signals in message POWERTRAIN_HEARTBEAT_ACK_FROM_MOTOR_CONTROLLER.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_powertrain_heartbeat_ack_from_motor_controller_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t powertrain_heartbeat_from_motor_controller_ack_status;
};

/**
 * Signals in message POWERTRAIN_HEARTBEAT_ACK_FROM_DRIVER_CONTROLS.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_powertrain_heartbeat_ack_from_driver_controls_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t powertrain_heartbeat_from_driver_controls_ack_status;
};

/**
 * Signals in message MOTOR_CONTROLLER_RESET.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_motor_controller_reset_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message OVUV_DCDC_AUX.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_ovuv_dcdc_aux_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t dcdc_ov_flag;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t dcdc_uv_flag;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t aux_bat_ov_flag;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t aux_bat_uv_flag;
};

/**
 * Signals in message MC_ERROR_LIMITS.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_mc_error_limits_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t error_id;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t limits;
};

/**
 * Signals in message DRIVE_OUTPUT.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_drive_output_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  int16_t throttle;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  int16_t direction;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  int16_t cruise_control;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  int16_t mechanical_brake_state;
};

/**
 * Signals in message CRUISE_TARGET.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_cruise_target_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  int8_t target_speed;
};

/**
 * Signals in message FAN_CONTROL.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_fan_control_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t state;
};

/**
 * Signals in message SET_DISCHARGE_BITSET.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_set_discharge_bitset_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint64_t discharge_bitset;
};

/**
 * Signals in message DISCHARGE_STATE.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_discharge_state_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint64_t discharge_bitset;
};

/**
 * Signals in message LIGHTS_SYNC.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_lights_sync_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message LIGHTS_STATE.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_lights_state_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t light_id;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t light_state;
};

/**
 * Signals in message HORN.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_horn_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t state;
};

/**
 * Signals in message CHARGER_CONN_STATE.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_charger_conn_state_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t is_connected;
};

/**
 * Signals in message CHARGER_SET_RELAY_STATE.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_charger_set_relay_state_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint8_t state;
};

/**
 * Signals in message STEERING_ANGLE.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_steering_angle_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t steering_angle;
};

/**
 * Signals in message BATTERY_SOC.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_battery_soc_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message BATTERY_VT.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_battery_vt_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t battery_vt_index;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_035;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_034;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_033;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_032;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_031;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_030;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_029;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_028;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_027;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_026;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_025;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_024;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_023;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_022;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_021;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_020;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_019;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_018;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_017;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_016;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_015;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_014;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_013;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_012;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_011;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_010;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_009;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_008;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_007;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_006;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_005;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_004;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_003;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_002;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_001;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_voltage_000;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_035;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_034;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_033;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_032;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_031;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_030;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_029;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_028;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_027;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_026;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_025;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_024;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_023;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_022;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_021;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_020;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_019;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_018;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_017;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_016;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_015;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_014;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_013;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_012;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_011;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_010;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_009;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_008;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_007;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_006;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_005;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_004;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_003;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_002;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_001;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_temp_000;
};

/**
 * Signals in message BATTERY_AGGREGATE_VC.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_battery_aggregate_vc_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint32_t voltage;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  int32_t current;
};

/**
 * Signals in message MOTOR_CONTROLLER_VC.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_motor_controller_vc_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t mc_voltage_1;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t mc_current_1;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t mc_voltage_2;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t mc_current_2;
};

/**
 * Signals in message MOTOR_VELOCITY.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_motor_velocity_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  int16_t vehicle_velocity_left;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  int16_t vehicle_velocity_right;
};

/**
 * Signals in message MOTOR_DEBUG.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_motor_debug_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint64_t data;
};

/**
 * Signals in message MOTOR_TEMPS.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_motor_temps_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint32_t motor_temp_l;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint32_t motor_temp_r;
};

/**
 * Signals in message MOTOR_AMP_HR.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_motor_amp_hr_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint32_t motor_amp_hr_l;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint32_t motor_amp_hr_r;
};

/**
 * Signals in message ODOMETER.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_odometer_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint32_t odometer_val;
};

/**
 * Signals in message AUX_DCDC_VC.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_aux_dcdc_vc_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t aux_voltage;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t aux_current;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t dcdc_voltage;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t dcdc_current;
};

/**
 * Signals in message DCDC_TEMPS.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_dcdc_temps_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t temp_1;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t temp_2;
};

/**
 * Signals in message SOLAR_DATA_FRONT.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_solar_data_front_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_id;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t voltage;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t current;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t temperature;
};

/**
 * Signals in message SOLAR_DATA_REAR.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_solar_data_rear_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t module_id;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t voltage;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t current;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t temperature;
};

/**
 * Signals in message CHARGER_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_charger_info_t {
  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t current;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t voltage;

  /**
   * Range: -
   * Scale: 1
   * Offset: 0
   */
  uint16_t status_bitset;
};

/**
 * Signals in message LINEAR_ACCELERATION.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_linear_acceleration_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Signals in message ANGULAR_ROTATION.
 *
 * All signal values are as on the CAN bus.
 */
struct system_can_angular_rotation_t {
  /**
   * Dummy signal in empty message.
   */
  uint8_t dummy;
};

/**
 * Pack message BPS_HEARTBEAT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_bps_heartbeat_pack(uint8_t *dst_p, const struct system_can_bps_heartbeat_t *src_p,
                                  size_t size);

/**
 * Unpack message BPS_HEARTBEAT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_bps_heartbeat_unpack(struct system_can_bps_heartbeat_t *dst_p, const uint8_t *src_p,
                                    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_bps_heartbeat_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_bps_heartbeat_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_bps_heartbeat_status_is_in_range(uint8_t value);

/**
 * Pack message BPS_HEARTBEAT_ACK_FROM_CHAOS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_bps_heartbeat_ack_from_chaos_pack(
    uint8_t *dst_p, const struct system_can_bps_heartbeat_ack_from_chaos_t *src_p, size_t size);

/**
 * Unpack message BPS_HEARTBEAT_ACK_FROM_CHAOS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_bps_heartbeat_ack_from_chaos_unpack(
    struct system_can_bps_heartbeat_ack_from_chaos_t *dst_p, const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_bps_heartbeat_ack_from_chaos_bps_heartbeat_from_chaos_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_bps_heartbeat_ack_from_chaos_bps_heartbeat_from_chaos_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_bps_heartbeat_ack_from_chaos_bps_heartbeat_from_chaos_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message BPS_HEARTBEAT_ACK_FROM_LIGHTS_FRONT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_bps_heartbeat_ack_from_lights_front_pack(
    uint8_t *dst_p, const struct system_can_bps_heartbeat_ack_from_lights_front_t *src_p,
    size_t size);

/**
 * Unpack message BPS_HEARTBEAT_ACK_FROM_LIGHTS_FRONT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_bps_heartbeat_ack_from_lights_front_unpack(
    struct system_can_bps_heartbeat_ack_from_lights_front_t *dst_p, const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_bps_heartbeat_ack_from_lights_front_bps_heartbeat_from_lights_front_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_bps_heartbeat_ack_from_lights_front_bps_heartbeat_from_lights_front_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_bps_heartbeat_ack_from_lights_front_bps_heartbeat_from_lights_front_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message BPS_HEARTBEAT_ACK_FROM_PLUTUS_SLAVE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_bps_heartbeat_ack_from_plutus_slave_pack(
    uint8_t *dst_p, const struct system_can_bps_heartbeat_ack_from_plutus_slave_t *src_p,
    size_t size);

/**
 * Unpack message BPS_HEARTBEAT_ACK_FROM_PLUTUS_SLAVE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_bps_heartbeat_ack_from_plutus_slave_unpack(
    struct system_can_bps_heartbeat_ack_from_plutus_slave_t *dst_p, const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_bps_heartbeat_ack_from_plutus_slave_bps_heartbeat_from_plutus_slave_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_bps_heartbeat_ack_from_plutus_slave_bps_heartbeat_from_plutus_slave_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_bps_heartbeat_ack_from_plutus_slave_bps_heartbeat_from_plutus_slave_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message BPS_HEARTBEAT_ACK_FROM_DRIVER_CONTROLS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_bps_heartbeat_ack_from_driver_controls_pack(
    uint8_t *dst_p, const struct system_can_bps_heartbeat_ack_from_driver_controls_t *src_p,
    size_t size);

/**
 * Unpack message BPS_HEARTBEAT_ACK_FROM_DRIVER_CONTROLS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_bps_heartbeat_ack_from_driver_controls_unpack(
    struct system_can_bps_heartbeat_ack_from_driver_controls_t *dst_p, const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_bps_heartbeat_ack_from_driver_controls_bps_heartbeat_from_driver_controls_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_bps_heartbeat_ack_from_driver_controls_bps_heartbeat_from_driver_controls_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_bps_heartbeat_ack_from_driver_controls_bps_heartbeat_from_driver_controls_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message POWER_DISTRIBUTION_FAULT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_power_distribution_fault_pack(
    uint8_t *dst_p, const struct system_can_power_distribution_fault_t *src_p, size_t size);

/**
 * Unpack message POWER_DISTRIBUTION_FAULT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_power_distribution_fault_unpack(struct system_can_power_distribution_fault_t *dst_p,
                                               const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_power_distribution_fault_reason_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_power_distribution_fault_reason_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_power_distribution_fault_reason_is_in_range(uint8_t value);

/**
 * Pack message POWER_DISTRIBUTION_FAULT_ACK_FROM_DRIVER_CONTROLS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_power_distribution_fault_ack_from_driver_controls_pack(
    uint8_t *dst_p,
    const struct system_can_power_distribution_fault_ack_from_driver_controls_t *src_p,
    size_t size);

/**
 * Unpack message POWER_DISTRIBUTION_FAULT_ACK_FROM_DRIVER_CONTROLS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_power_distribution_fault_ack_from_driver_controls_unpack(
    struct system_can_power_distribution_fault_ack_from_driver_controls_t *dst_p,
    const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_power_distribution_fault_ack_from_driver_controls_power_distribution_fault_from_driver_controls_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_power_distribution_fault_ack_from_driver_controls_power_distribution_fault_from_driver_controls_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_power_distribution_fault_ack_from_driver_controls_power_distribution_fault_from_driver_controls_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message BATTERY_RELAY_MAIN.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_battery_relay_main_pack(uint8_t *dst_p,
                                       const struct system_can_battery_relay_main_t *src_p,
                                       size_t size);

/**
 * Unpack message BATTERY_RELAY_MAIN.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_battery_relay_main_unpack(struct system_can_battery_relay_main_t *dst_p,
                                         const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_battery_relay_main_relay_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_relay_main_relay_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_relay_main_relay_state_is_in_range(uint8_t value);

/**
 * Pack message BATTERY_RELAY_MAIN_ACK_FROM_PLUTUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_battery_relay_main_ack_from_plutus_pack(
    uint8_t *dst_p, const struct system_can_battery_relay_main_ack_from_plutus_t *src_p,
    size_t size);

/**
 * Unpack message BATTERY_RELAY_MAIN_ACK_FROM_PLUTUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_battery_relay_main_ack_from_plutus_unpack(
    struct system_can_battery_relay_main_ack_from_plutus_t *dst_p, const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_battery_relay_main_ack_from_plutus_battery_relay_main_from_plutus_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_battery_relay_main_ack_from_plutus_battery_relay_main_from_plutus_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_relay_main_ack_from_plutus_battery_relay_main_from_plutus_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message BATTERY_RELAY_SLAVE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_battery_relay_slave_pack(uint8_t *dst_p,
                                        const struct system_can_battery_relay_slave_t *src_p,
                                        size_t size);

/**
 * Unpack message BATTERY_RELAY_SLAVE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_battery_relay_slave_unpack(struct system_can_battery_relay_slave_t *dst_p,
                                          const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_battery_relay_slave_relay_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_relay_slave_relay_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_relay_slave_relay_state_is_in_range(uint8_t value);

/**
 * Pack message BATTERY_RELAY_SLAVE_ACK_FROM_PLUTUS_SLAVE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_battery_relay_slave_ack_from_plutus_slave_pack(
    uint8_t *dst_p, const struct system_can_battery_relay_slave_ack_from_plutus_slave_t *src_p,
    size_t size);

/**
 * Unpack message BATTERY_RELAY_SLAVE_ACK_FROM_PLUTUS_SLAVE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_battery_relay_slave_ack_from_plutus_slave_unpack(
    struct system_can_battery_relay_slave_ack_from_plutus_slave_t *dst_p, const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_battery_relay_slave_ack_from_plutus_slave_battery_relay_slave_from_plutus_slave_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_battery_relay_slave_ack_from_plutus_slave_battery_relay_slave_from_plutus_slave_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_relay_slave_ack_from_plutus_slave_battery_relay_slave_from_plutus_slave_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message MOTOR_RELAY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_motor_relay_pack(uint8_t *dst_p, const struct system_can_motor_relay_t *src_p,
                                size_t size);

/**
 * Unpack message MOTOR_RELAY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_motor_relay_unpack(struct system_can_motor_relay_t *dst_p, const uint8_t *src_p,
                                  size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_motor_relay_relay_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_relay_relay_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_relay_relay_state_is_in_range(uint8_t value);

/**
 * Pack message MOTOR_RELAY_ACK_FROM_MOTOR_CONTROLLER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_motor_relay_ack_from_motor_controller_pack(
    uint8_t *dst_p, const struct system_can_motor_relay_ack_from_motor_controller_t *src_p,
    size_t size);

/**
 * Unpack message MOTOR_RELAY_ACK_FROM_MOTOR_CONTROLLER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_motor_relay_ack_from_motor_controller_unpack(
    struct system_can_motor_relay_ack_from_motor_controller_t *dst_p, const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_motor_relay_ack_from_motor_controller_motor_relay_from_motor_controller_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_motor_relay_ack_from_motor_controller_motor_relay_from_motor_controller_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_relay_ack_from_motor_controller_motor_relay_from_motor_controller_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message SOLAR_RELAY_REAR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_solar_relay_rear_pack(uint8_t *dst_p,
                                     const struct system_can_solar_relay_rear_t *src_p,
                                     size_t size);

/**
 * Unpack message SOLAR_RELAY_REAR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_solar_relay_rear_unpack(struct system_can_solar_relay_rear_t *dst_p,
                                       const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_solar_relay_rear_relay_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_solar_relay_rear_relay_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_relay_rear_relay_state_is_in_range(uint8_t value);

/**
 * Pack message SOLAR_RELAY_REAR_ACK_FROM_SOLAR_MASTER_REAR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_solar_relay_rear_ack_from_solar_master_rear_pack(
    uint8_t *dst_p, const struct system_can_solar_relay_rear_ack_from_solar_master_rear_t *src_p,
    size_t size);

/**
 * Unpack message SOLAR_RELAY_REAR_ACK_FROM_SOLAR_MASTER_REAR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_solar_relay_rear_ack_from_solar_master_rear_unpack(
    struct system_can_solar_relay_rear_ack_from_solar_master_rear_t *dst_p, const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_solar_relay_rear_ack_from_solar_master_rear_solar_relay_rear_from_solar_master_rear_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_solar_relay_rear_ack_from_solar_master_rear_solar_relay_rear_from_solar_master_rear_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_relay_rear_ack_from_solar_master_rear_solar_relay_rear_from_solar_master_rear_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message SOLAR_RELAY_FRONT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_solar_relay_front_pack(uint8_t *dst_p,
                                      const struct system_can_solar_relay_front_t *src_p,
                                      size_t size);

/**
 * Unpack message SOLAR_RELAY_FRONT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_solar_relay_front_unpack(struct system_can_solar_relay_front_t *dst_p,
                                        const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_solar_relay_front_relay_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_solar_relay_front_relay_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_relay_front_relay_state_is_in_range(uint8_t value);

/**
 * Pack message SOLAR_RELAY_FRONT_ACK_FROM_SOLAR_MASTER_FRONT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_solar_relay_front_ack_from_solar_master_front_pack(
    uint8_t *dst_p, const struct system_can_solar_relay_front_ack_from_solar_master_front_t *src_p,
    size_t size);

/**
 * Unpack message SOLAR_RELAY_FRONT_ACK_FROM_SOLAR_MASTER_FRONT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_solar_relay_front_ack_from_solar_master_front_unpack(
    struct system_can_solar_relay_front_ack_from_solar_master_front_t *dst_p, const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_solar_relay_front_ack_from_solar_master_front_solar_relay_front_from_solar_master_front_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_solar_relay_front_ack_from_solar_master_front_solar_relay_front_from_solar_master_front_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_relay_front_ack_from_solar_master_front_solar_relay_front_from_solar_master_front_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message POWER_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_power_state_pack(uint8_t *dst_p, const struct system_can_power_state_t *src_p,
                                size_t size);

/**
 * Unpack message POWER_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_power_state_unpack(struct system_can_power_state_t *dst_p, const uint8_t *src_p,
                                  size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_power_state_power_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_power_state_power_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_power_state_power_state_is_in_range(uint8_t value);

/**
 * Pack message POWER_STATE_ACK_FROM_CHAOS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_power_state_ack_from_chaos_pack(
    uint8_t *dst_p, const struct system_can_power_state_ack_from_chaos_t *src_p, size_t size);

/**
 * Unpack message POWER_STATE_ACK_FROM_CHAOS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_power_state_ack_from_chaos_unpack(
    struct system_can_power_state_ack_from_chaos_t *dst_p, const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_power_state_ack_from_chaos_power_state_from_chaos_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_power_state_ack_from_chaos_power_state_from_chaos_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_power_state_ack_from_chaos_power_state_from_chaos_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message POWERTRAIN_HEARTBEAT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_powertrain_heartbeat_pack(uint8_t *dst_p,
                                         const struct system_can_powertrain_heartbeat_t *src_p,
                                         size_t size);

/**
 * Unpack message POWERTRAIN_HEARTBEAT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_powertrain_heartbeat_unpack(struct system_can_powertrain_heartbeat_t *dst_p,
                                           const uint8_t *src_p, size_t size);

/**
 * Pack message POWERTRAIN_HEARTBEAT_ACK_FROM_PLUTUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_powertrain_heartbeat_ack_from_plutus_pack(
    uint8_t *dst_p, const struct system_can_powertrain_heartbeat_ack_from_plutus_t *src_p,
    size_t size);

/**
 * Unpack message POWERTRAIN_HEARTBEAT_ACK_FROM_PLUTUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_powertrain_heartbeat_ack_from_plutus_unpack(
    struct system_can_powertrain_heartbeat_ack_from_plutus_t *dst_p, const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_powertrain_heartbeat_ack_from_plutus_powertrain_heartbeat_from_plutus_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_powertrain_heartbeat_ack_from_plutus_powertrain_heartbeat_from_plutus_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_powertrain_heartbeat_ack_from_plutus_powertrain_heartbeat_from_plutus_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message POWERTRAIN_HEARTBEAT_ACK_FROM_MOTOR_CONTROLLER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_powertrain_heartbeat_ack_from_motor_controller_pack(
    uint8_t *dst_p, const struct system_can_powertrain_heartbeat_ack_from_motor_controller_t *src_p,
    size_t size);

/**
 * Unpack message POWERTRAIN_HEARTBEAT_ACK_FROM_MOTOR_CONTROLLER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_powertrain_heartbeat_ack_from_motor_controller_unpack(
    struct system_can_powertrain_heartbeat_ack_from_motor_controller_t *dst_p, const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_powertrain_heartbeat_ack_from_motor_controller_powertrain_heartbeat_from_motor_controller_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_powertrain_heartbeat_ack_from_motor_controller_powertrain_heartbeat_from_motor_controller_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_powertrain_heartbeat_ack_from_motor_controller_powertrain_heartbeat_from_motor_controller_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message POWERTRAIN_HEARTBEAT_ACK_FROM_DRIVER_CONTROLS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_powertrain_heartbeat_ack_from_driver_controls_pack(
    uint8_t *dst_p, const struct system_can_powertrain_heartbeat_ack_from_driver_controls_t *src_p,
    size_t size);

/**
 * Unpack message POWERTRAIN_HEARTBEAT_ACK_FROM_DRIVER_CONTROLS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_powertrain_heartbeat_ack_from_driver_controls_unpack(
    struct system_can_powertrain_heartbeat_ack_from_driver_controls_t *dst_p, const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t
system_can_powertrain_heartbeat_ack_from_driver_controls_powertrain_heartbeat_from_driver_controls_ack_status_encode(
    double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double
system_can_powertrain_heartbeat_ack_from_driver_controls_powertrain_heartbeat_from_driver_controls_ack_status_decode(
    uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_powertrain_heartbeat_ack_from_driver_controls_powertrain_heartbeat_from_driver_controls_ack_status_is_in_range(
    uint8_t value);

/**
 * Pack message MOTOR_CONTROLLER_RESET.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_motor_controller_reset_pack(uint8_t *dst_p,
                                           const struct system_can_motor_controller_reset_t *src_p,
                                           size_t size);

/**
 * Unpack message MOTOR_CONTROLLER_RESET.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_motor_controller_reset_unpack(struct system_can_motor_controller_reset_t *dst_p,
                                             const uint8_t *src_p, size_t size);

/**
 * Pack message OVUV_DCDC_AUX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_ovuv_dcdc_aux_pack(uint8_t *dst_p, const struct system_can_ovuv_dcdc_aux_t *src_p,
                                  size_t size);

/**
 * Unpack message OVUV_DCDC_AUX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_ovuv_dcdc_aux_unpack(struct system_can_ovuv_dcdc_aux_t *dst_p, const uint8_t *src_p,
                                    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_ovuv_dcdc_aux_dcdc_ov_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_ovuv_dcdc_aux_dcdc_ov_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_ovuv_dcdc_aux_dcdc_ov_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_ovuv_dcdc_aux_dcdc_uv_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_ovuv_dcdc_aux_dcdc_uv_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_ovuv_dcdc_aux_dcdc_uv_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_ovuv_dcdc_aux_aux_bat_ov_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_ovuv_dcdc_aux_aux_bat_ov_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_ovuv_dcdc_aux_aux_bat_ov_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_ovuv_dcdc_aux_aux_bat_uv_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_ovuv_dcdc_aux_aux_bat_uv_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_ovuv_dcdc_aux_aux_bat_uv_flag_is_in_range(uint8_t value);

/**
 * Pack message MC_ERROR_LIMITS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_mc_error_limits_pack(uint8_t *dst_p,
                                    const struct system_can_mc_error_limits_t *src_p, size_t size);

/**
 * Unpack message MC_ERROR_LIMITS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_mc_error_limits_unpack(struct system_can_mc_error_limits_t *dst_p,
                                      const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_mc_error_limits_error_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_mc_error_limits_error_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_mc_error_limits_error_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_mc_error_limits_limits_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_mc_error_limits_limits_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_mc_error_limits_limits_is_in_range(uint16_t value);

/**
 * Pack message DRIVE_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_drive_output_pack(uint8_t *dst_p, const struct system_can_drive_output_t *src_p,
                                 size_t size);

/**
 * Unpack message DRIVE_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_drive_output_unpack(struct system_can_drive_output_t *dst_p, const uint8_t *src_p,
                                   size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t system_can_drive_output_throttle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_drive_output_throttle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_drive_output_throttle_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t system_can_drive_output_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_drive_output_direction_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_drive_output_direction_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t system_can_drive_output_cruise_control_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_drive_output_cruise_control_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_drive_output_cruise_control_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t system_can_drive_output_mechanical_brake_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_drive_output_mechanical_brake_state_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_drive_output_mechanical_brake_state_is_in_range(int16_t value);

/**
 * Pack message CRUISE_TARGET.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_cruise_target_pack(uint8_t *dst_p, const struct system_can_cruise_target_t *src_p,
                                  size_t size);

/**
 * Unpack message CRUISE_TARGET.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_cruise_target_unpack(struct system_can_cruise_target_t *dst_p, const uint8_t *src_p,
                                    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t system_can_cruise_target_target_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_cruise_target_target_speed_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_cruise_target_target_speed_is_in_range(int8_t value);

/**
 * Pack message FAN_CONTROL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_fan_control_pack(uint8_t *dst_p, const struct system_can_fan_control_t *src_p,
                                size_t size);

/**
 * Unpack message FAN_CONTROL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_fan_control_unpack(struct system_can_fan_control_t *dst_p, const uint8_t *src_p,
                                  size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_fan_control_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_fan_control_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_fan_control_state_is_in_range(uint8_t value);

/**
 * Pack message SET_DISCHARGE_BITSET.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_set_discharge_bitset_pack(uint8_t *dst_p,
                                         const struct system_can_set_discharge_bitset_t *src_p,
                                         size_t size);

/**
 * Unpack message SET_DISCHARGE_BITSET.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_set_discharge_bitset_unpack(struct system_can_set_discharge_bitset_t *dst_p,
                                           const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t system_can_set_discharge_bitset_discharge_bitset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_set_discharge_bitset_discharge_bitset_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_set_discharge_bitset_discharge_bitset_is_in_range(uint64_t value);

/**
 * Pack message DISCHARGE_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_discharge_state_pack(uint8_t *dst_p,
                                    const struct system_can_discharge_state_t *src_p, size_t size);

/**
 * Unpack message DISCHARGE_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_discharge_state_unpack(struct system_can_discharge_state_t *dst_p,
                                      const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t system_can_discharge_state_discharge_bitset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_discharge_state_discharge_bitset_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_discharge_state_discharge_bitset_is_in_range(uint64_t value);

/**
 * Pack message LIGHTS_SYNC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_lights_sync_pack(uint8_t *dst_p, const struct system_can_lights_sync_t *src_p,
                                size_t size);

/**
 * Unpack message LIGHTS_SYNC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_lights_sync_unpack(struct system_can_lights_sync_t *dst_p, const uint8_t *src_p,
                                  size_t size);

/**
 * Pack message LIGHTS_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_lights_state_pack(uint8_t *dst_p, const struct system_can_lights_state_t *src_p,
                                 size_t size);

/**
 * Unpack message LIGHTS_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_lights_state_unpack(struct system_can_lights_state_t *dst_p, const uint8_t *src_p,
                                   size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_lights_state_light_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_lights_state_light_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_lights_state_light_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_lights_state_light_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_lights_state_light_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_lights_state_light_state_is_in_range(uint8_t value);

/**
 * Pack message HORN.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_horn_pack(uint8_t *dst_p, const struct system_can_horn_t *src_p, size_t size);

/**
 * Unpack message HORN.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_horn_unpack(struct system_can_horn_t *dst_p, const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_horn_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_horn_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_horn_state_is_in_range(uint8_t value);

/**
 * Pack message CHARGER_CONN_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_charger_conn_state_pack(uint8_t *dst_p,
                                       const struct system_can_charger_conn_state_t *src_p,
                                       size_t size);

/**
 * Unpack message CHARGER_CONN_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_charger_conn_state_unpack(struct system_can_charger_conn_state_t *dst_p,
                                         const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_charger_conn_state_is_connected_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_charger_conn_state_is_connected_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_charger_conn_state_is_connected_is_in_range(uint8_t value);

/**
 * Pack message CHARGER_SET_RELAY_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_charger_set_relay_state_pack(
    uint8_t *dst_p, const struct system_can_charger_set_relay_state_t *src_p, size_t size);

/**
 * Unpack message CHARGER_SET_RELAY_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_charger_set_relay_state_unpack(struct system_can_charger_set_relay_state_t *dst_p,
                                              const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t system_can_charger_set_relay_state_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_charger_set_relay_state_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_charger_set_relay_state_state_is_in_range(uint8_t value);

/**
 * Pack message STEERING_ANGLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_steering_angle_pack(uint8_t *dst_p, const struct system_can_steering_angle_t *src_p,
                                   size_t size);

/**
 * Unpack message STEERING_ANGLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_steering_angle_unpack(struct system_can_steering_angle_t *dst_p,
                                     const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_steering_angle_steering_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_steering_angle_steering_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_steering_angle_steering_angle_is_in_range(uint16_t value);

/**
 * Pack message BATTERY_SOC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_battery_soc_pack(uint8_t *dst_p, const struct system_can_battery_soc_t *src_p,
                                size_t size);

/**
 * Unpack message BATTERY_SOC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_battery_soc_unpack(struct system_can_battery_soc_t *dst_p, const uint8_t *src_p,
                                  size_t size);

/**
 * Pack message BATTERY_VT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_battery_vt_pack(uint8_t *dst_p, const struct system_can_battery_vt_t *src_p,
                               size_t size);

/**
 * Unpack message BATTERY_VT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_battery_vt_unpack(struct system_can_battery_vt_t *dst_p, const uint8_t *src_p,
                                 size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_battery_vt_index_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_battery_vt_index_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_battery_vt_index_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_035_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_035_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_035_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_034_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_034_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_034_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_033_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_033_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_033_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_032_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_032_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_032_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_031_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_031_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_031_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_030_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_030_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_030_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_029_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_029_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_029_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_028_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_028_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_028_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_027_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_027_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_027_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_026_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_026_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_026_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_025_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_025_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_025_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_024_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_024_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_024_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_023_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_023_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_023_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_022_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_022_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_022_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_021_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_021_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_021_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_020_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_020_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_020_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_019_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_019_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_019_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_018_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_018_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_018_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_017_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_017_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_017_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_016_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_016_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_016_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_015_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_015_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_015_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_014_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_014_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_014_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_013_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_013_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_013_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_012_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_012_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_012_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_011_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_011_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_011_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_010_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_010_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_010_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_009_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_009_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_009_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_008_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_008_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_008_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_007_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_007_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_007_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_006_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_006_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_006_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_005_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_005_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_005_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_004_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_004_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_004_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_003_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_003_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_003_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_002_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_002_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_002_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_001_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_001_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_001_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_voltage_000_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_voltage_000_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_voltage_000_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_035_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_035_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_035_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_034_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_034_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_034_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_033_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_033_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_033_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_032_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_032_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_032_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_031_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_031_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_031_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_030_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_030_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_030_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_029_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_029_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_029_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_028_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_028_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_028_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_027_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_027_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_027_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_026_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_026_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_026_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_025_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_025_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_025_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_024_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_024_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_024_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_023_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_023_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_023_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_022_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_022_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_022_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_021_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_021_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_021_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_020_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_020_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_020_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_019_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_019_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_019_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_018_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_018_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_018_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_017_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_017_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_017_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_016_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_016_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_016_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_015_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_015_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_015_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_014_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_014_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_014_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_013_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_013_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_013_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_012_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_012_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_012_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_011_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_011_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_011_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_010_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_010_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_010_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_009_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_009_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_009_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_008_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_008_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_008_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_007_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_007_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_007_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_006_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_006_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_006_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_005_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_005_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_005_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_004_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_004_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_004_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_003_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_003_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_003_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_002_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_002_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_002_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_001_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_001_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_001_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_battery_vt_module_temp_000_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_vt_module_temp_000_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_vt_module_temp_000_is_in_range(uint16_t value);

/**
 * Pack message BATTERY_AGGREGATE_VC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_battery_aggregate_vc_pack(uint8_t *dst_p,
                                         const struct system_can_battery_aggregate_vc_t *src_p,
                                         size_t size);

/**
 * Unpack message BATTERY_AGGREGATE_VC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_battery_aggregate_vc_unpack(struct system_can_battery_aggregate_vc_t *dst_p,
                                           const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t system_can_battery_aggregate_vc_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_aggregate_vc_voltage_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_aggregate_vc_voltage_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t system_can_battery_aggregate_vc_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_battery_aggregate_vc_current_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_battery_aggregate_vc_current_is_in_range(int32_t value);

/**
 * Pack message MOTOR_CONTROLLER_VC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_motor_controller_vc_pack(uint8_t *dst_p,
                                        const struct system_can_motor_controller_vc_t *src_p,
                                        size_t size);

/**
 * Unpack message MOTOR_CONTROLLER_VC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_motor_controller_vc_unpack(struct system_can_motor_controller_vc_t *dst_p,
                                          const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_motor_controller_vc_mc_voltage_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_controller_vc_mc_voltage_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_controller_vc_mc_voltage_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_motor_controller_vc_mc_current_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_controller_vc_mc_current_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_controller_vc_mc_current_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_motor_controller_vc_mc_voltage_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_controller_vc_mc_voltage_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_controller_vc_mc_voltage_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_motor_controller_vc_mc_current_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_controller_vc_mc_current_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_controller_vc_mc_current_2_is_in_range(uint16_t value);

/**
 * Pack message MOTOR_VELOCITY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_motor_velocity_pack(uint8_t *dst_p, const struct system_can_motor_velocity_t *src_p,
                                   size_t size);

/**
 * Unpack message MOTOR_VELOCITY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_motor_velocity_unpack(struct system_can_motor_velocity_t *dst_p,
                                     const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t system_can_motor_velocity_vehicle_velocity_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_velocity_vehicle_velocity_left_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_velocity_vehicle_velocity_left_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t system_can_motor_velocity_vehicle_velocity_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_velocity_vehicle_velocity_right_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_velocity_vehicle_velocity_right_is_in_range(int16_t value);

/**
 * Pack message MOTOR_DEBUG.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_motor_debug_pack(uint8_t *dst_p, const struct system_can_motor_debug_t *src_p,
                                size_t size);

/**
 * Unpack message MOTOR_DEBUG.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_motor_debug_unpack(struct system_can_motor_debug_t *dst_p, const uint8_t *src_p,
                                  size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t system_can_motor_debug_data_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_debug_data_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_debug_data_is_in_range(uint64_t value);

/**
 * Pack message MOTOR_TEMPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_motor_temps_pack(uint8_t *dst_p, const struct system_can_motor_temps_t *src_p,
                                size_t size);

/**
 * Unpack message MOTOR_TEMPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_motor_temps_unpack(struct system_can_motor_temps_t *dst_p, const uint8_t *src_p,
                                  size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t system_can_motor_temps_motor_temp_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_temps_motor_temp_l_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_temps_motor_temp_l_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t system_can_motor_temps_motor_temp_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_temps_motor_temp_r_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_temps_motor_temp_r_is_in_range(uint32_t value);

/**
 * Pack message MOTOR_AMP_HR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_motor_amp_hr_pack(uint8_t *dst_p, const struct system_can_motor_amp_hr_t *src_p,
                                 size_t size);

/**
 * Unpack message MOTOR_AMP_HR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_motor_amp_hr_unpack(struct system_can_motor_amp_hr_t *dst_p, const uint8_t *src_p,
                                   size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t system_can_motor_amp_hr_motor_amp_hr_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_amp_hr_motor_amp_hr_l_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_amp_hr_motor_amp_hr_l_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t system_can_motor_amp_hr_motor_amp_hr_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_motor_amp_hr_motor_amp_hr_r_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_motor_amp_hr_motor_amp_hr_r_is_in_range(uint32_t value);

/**
 * Pack message ODOMETER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_odometer_pack(uint8_t *dst_p, const struct system_can_odometer_t *src_p,
                             size_t size);

/**
 * Unpack message ODOMETER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_odometer_unpack(struct system_can_odometer_t *dst_p, const uint8_t *src_p,
                               size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t system_can_odometer_odometer_val_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_odometer_odometer_val_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_odometer_odometer_val_is_in_range(uint32_t value);

/**
 * Pack message AUX_DCDC_VC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_aux_dcdc_vc_pack(uint8_t *dst_p, const struct system_can_aux_dcdc_vc_t *src_p,
                                size_t size);

/**
 * Unpack message AUX_DCDC_VC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_aux_dcdc_vc_unpack(struct system_can_aux_dcdc_vc_t *dst_p, const uint8_t *src_p,
                                  size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_aux_dcdc_vc_aux_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_aux_dcdc_vc_aux_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_aux_dcdc_vc_aux_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_aux_dcdc_vc_aux_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_aux_dcdc_vc_aux_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_aux_dcdc_vc_aux_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_aux_dcdc_vc_dcdc_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_aux_dcdc_vc_dcdc_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_aux_dcdc_vc_dcdc_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_aux_dcdc_vc_dcdc_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_aux_dcdc_vc_dcdc_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_aux_dcdc_vc_dcdc_current_is_in_range(uint16_t value);

/**
 * Pack message DCDC_TEMPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_dcdc_temps_pack(uint8_t *dst_p, const struct system_can_dcdc_temps_t *src_p,
                               size_t size);

/**
 * Unpack message DCDC_TEMPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_dcdc_temps_unpack(struct system_can_dcdc_temps_t *dst_p, const uint8_t *src_p,
                                 size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_dcdc_temps_temp_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_dcdc_temps_temp_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_dcdc_temps_temp_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_dcdc_temps_temp_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_dcdc_temps_temp_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_dcdc_temps_temp_2_is_in_range(uint16_t value);

/**
 * Pack message SOLAR_DATA_FRONT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_solar_data_front_pack(uint8_t *dst_p,
                                     const struct system_can_solar_data_front_t *src_p,
                                     size_t size);

/**
 * Unpack message SOLAR_DATA_FRONT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_solar_data_front_unpack(struct system_can_solar_data_front_t *dst_p,
                                       const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_solar_data_front_module_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_solar_data_front_module_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_data_front_module_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_solar_data_front_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_solar_data_front_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_data_front_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_solar_data_front_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_solar_data_front_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_data_front_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_solar_data_front_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_solar_data_front_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_data_front_temperature_is_in_range(uint16_t value);

/**
 * Pack message SOLAR_DATA_REAR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_solar_data_rear_pack(uint8_t *dst_p,
                                    const struct system_can_solar_data_rear_t *src_p, size_t size);

/**
 * Unpack message SOLAR_DATA_REAR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_solar_data_rear_unpack(struct system_can_solar_data_rear_t *dst_p,
                                      const uint8_t *src_p, size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_solar_data_rear_module_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_solar_data_rear_module_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_data_rear_module_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_solar_data_rear_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_solar_data_rear_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_data_rear_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_solar_data_rear_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_solar_data_rear_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_data_rear_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_solar_data_rear_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_solar_data_rear_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_solar_data_rear_temperature_is_in_range(uint16_t value);

/**
 * Pack message CHARGER_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_charger_info_pack(uint8_t *dst_p, const struct system_can_charger_info_t *src_p,
                                 size_t size);

/**
 * Unpack message CHARGER_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_charger_info_unpack(struct system_can_charger_info_t *dst_p, const uint8_t *src_p,
                                   size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_charger_info_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_charger_info_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_charger_info_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_charger_info_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_charger_info_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_charger_info_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t system_can_charger_info_status_bitset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double system_can_charger_info_status_bitset_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool system_can_charger_info_status_bitset_is_in_range(uint16_t value);

/**
 * Pack message LINEAR_ACCELERATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_linear_acceleration_pack(uint8_t *dst_p,
                                        const struct system_can_linear_acceleration_t *src_p,
                                        size_t size);

/**
 * Unpack message LINEAR_ACCELERATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_linear_acceleration_unpack(struct system_can_linear_acceleration_t *dst_p,
                                          const uint8_t *src_p, size_t size);

/**
 * Pack message ANGULAR_ROTATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int system_can_angular_rotation_pack(uint8_t *dst_p,
                                     const struct system_can_angular_rotation_t *src_p,
                                     size_t size);

/**
 * Unpack message ANGULAR_ROTATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int system_can_angular_rotation_unpack(struct system_can_angular_rotation_t *dst_p,
                                       const uint8_t *src_p, size_t size);

#endif
