#include "steering_indicator.h"
#include "can_msg_defs.h"
#include "can_unpack.h"
#include "cc_input_event.h"
#include "exported_enums.h"
#include "log.h"

static const EventId s_steering_output_mapping[NUM_EE_CONTROL_STALK_EVENTS] = {
  // Analog event mapping
  [EE_CONTROL_STALK_ANALOG_DISTANCE_NEUTRAL] = INPUT_EVENT_CONTROL_STALK_ANALOG_DISTANCE_NEUTRAL,
  [EE_CONTROL_STALK_ANALOG_DISTANCE_MINUS] = INPUT_EVENT_CONTROL_STALK_ANALOG_DISTANCE_MINUS,
  [EE_CONTROL_STALK_ANALOG_DISTANCE_PLUS] = INPUT_EVENT_CONTROL_STALK_ANALOG_DISTANCE_PLUS,
  [EE_CONTROL_STALK_ANALOG_CC_SPEED_NEUTRAL] = INPUT_EVENT_CONTROL_STALK_ANALOG_CC_SPEED_NEUTRAL,

  [EE_CONTROL_STALK_ANALOG_CC_SPEED_MINUS] = INPUT_EVENT_CONTROL_STALK_ANALOG_CC_SPEED_MINUS,
  [EE_CONTROL_STALK_ANALOG_CC_SPEED_PLUS] = INPUT_EVENT_CONTROL_STALK_ANALOG_CC_SPEED_PLUS,
  [EE_CONTROL_STALK_ANALOG_CC_DIGITAL] = INPUT_EVENT_CONTROL_STALK_ANALOG_CC_DIGITAL,

  [EE_CONTROL_STALK_ANALOG_CC_CANCEL] = INPUT_EVENT_CONTROL_STALK_ANALOG_CC_CANCEL,
  [EE_CONTROL_STALK_ANALOG_CC_RESUME] = INPUT_EVENT_CONTROL_STALK_ANALOG_CC_RESUME,
  [EE_CONTROL_STALK_ANALOG_CC_TURN_SIGNAL_NONE] = INPUT_EVENT_CONTROL_STALK_ANALOG_TURN_SIGNAL_NONE,

  [EE_CONTROL_STALK_ANALOG_CC_TURN_SIGNAL_RIGHT] =
      INPUT_EVENT_CONTROL_STALK_ANALOG_TURN_SIGNAL_RIGHT,
  [EE_CONTROL_STALK_ANALOG_CC_TURN_SIGNAL_LEFT] = INPUT_EVENT_CONTROL_STALK_ANALOG_TURN_SIGNAL_LEFT,
  [EE_CONTROL_STALK_DIGITAL_CC_SET_PRESSED] = INPUT_EVENT_CONTROL_STALK_DIGITAL_CC_SET_PRESSED,

  // Digital event mapping
  [EE_CONTROL_STALK_DIGITAL_CC_SET_RELEASED] = INPUT_EVENT_CONTROL_STALK_DIGITAL_CC_SET_RELEASED,
  [EE_CONTROL_STALK_DIGITAL_CC_OFF] = INPUT_EVENT_CONTROL_STALK_DIGITAL_CC_OFF,
  [EE_CONTROL_STALK_DIGITAL_CC_ON] = INPUT_EVENT_CONTROL_STALK_DIGITAL_CC_ON,
  [EE_CONTROL_STALK_DIGITAL_CC_LANE_ASSIST_PRESSED] =
      INPUT_EVENT_CONTROL_STALK_DIGITAL_CC_LANE_ASSIST_PRESSED,
  [EE_CONTROL_STALK_DIGITAL_CC_LANE_ASSIST_RELEASED] =
      INPUT_EVENT_CONTROL_STALK_DIGITAL_CC_LANE_ASSIST_RELEASED,
  [EE_CONTROL_STALK_DIGITAL_HIGH_BEAM_FWD_PRESSED] =
      INPUT_EVENT_CONTROL_STALK_DIGITAL_HEADLIGHT_FWD_PRESSED,
  [EE_CONTROL_STALK_DIGITAL_HIGH_BEAM_FWD_RELEASED] =
      INPUT_EVENT_CONTROL_STALK_DIGITAL_HEADLIGHT_FWD_RELEASED,
  [EE_CONTROL_STALK_DIGITAL_HIGH_BEAM_BACK_PRESSED] =
      INPUT_EVENT_CONTROL_STALK_DIGITAL_HEADLIGHT_BACK_PRESSED,
  [EE_CONTROL_STALK_DIGITAL_HIGH_BEAM_BACK_RELEASED] =
      INPUT_EVENT_CONTROL_STALK_DIGITAL_HEADLIGHT_BACK_RELEASED,
  [EE_CONTROL_STALK_DIGITAL_HORN_PRESSED] = INPUT_EVENT_CONTROL_STALK_DIGITAL_HORN_PRESSED,
  [EE_CONTROL_STALK_DIGITAL_HORN_RELEASED] = INPUT_EVENT_CONTROL_STALK_DIGITAL_HORN_RELEASED,
};

static StatusCode prv_handle_steering(const CanMessage *msg, void *context,
                                      CanAckStatus *ack_reply) {
  uint16_t event_id = 0;
  uint16_t data = 0;

  CAN_UNPACK_STEERING_OUTPUT(msg, &event_id, &data);

  if (!(event_id < SIZEOF_ARRAY(s_steering_output_mapping))) {
    LOG_DEBUG("Steering: CAN to event mapping out of range\n");
    return status_code(STATUS_CODE_OUT_OF_RANGE);
  }

  event_raise(s_steering_output_mapping[event_id], 0);
  return STATUS_CODE_OK;
}

StatusCode steering_indicator_init(void) {
  return can_register_rx_handler(SYSTEM_CAN_MESSAGE_STEERING_OUTPUT, prv_handle_steering, NULL);
}
